---
title: Redis的分布式锁
date: 2022-07-17T19:50:23+08:00
lastmod: 2022-07-17T19:50:23+08:00

cover: https://aria9766.oss-cn-beijing.aliyuncs.com/blog-pictures/6_15/sand_of_time.jpg
# images:
#   - /img/cover.jpg
categories:
  - 数据库
tags:
  - redis
  - 分布式锁
# nolastmod: true
draft: false
---

redis用于分布式锁

<!--more-->

## 分布式锁的作用？

对于一个进程的多线程并发，在操作共享变量时，通常会使用锁来确保结果的正确性。对于多个进程同时操作一个共享资源的时候，就需要引入分布式锁来解决。

分布式锁的实现需要借助一个外部系统，所有进程取该系统申请锁，并且该外部系统在可接受的时间内只会为一个进程提供锁。通常这个外部系统会采用MySQL，Redis或ZooKeeper来实现。为了追求更好的性能，通常使用Redis或Zookeeper实现。

## Redis如何实现分布式锁？

在redis中，提供了SETNX命令，这个命令表示SET IF NOT EXISTS，只有key不存在才会设置它的值，否则什么都不做。释放锁只要DEL删掉该key即可。

但在这种情况下，如果获取锁的进程挂掉，则锁就会永远无法释放。解决方式也很简单，通过租期的方式，给key加上有效期，并且要保证操作的原子性。

仍然存在以下的情况：

1、client A获得锁lock

2、client A操作超时， 锁被释放

3、client B获得同名锁lock

4、client A释放锁lock，但是此时释放的是B的lock

这里存在了两个问题：

1、锁过期，实际操作的时间只能大致估计，服务器或者网络异常是无法预料的，可以通过守护线程续租的方式解决（Java中的Redisson）。

2、释放别人的锁，只要给每个进程分配的锁ID唯一则不会产生这种情况。

## Redis集群下要如何使用？

redis中一般会采用主从集群+哨兵的部署模式，主库宕机后，可以通过哨兵进行故障的自动切换，保证服务可用性。

经典问题：client在主库加锁成功，在未同步到从库上时候主库宕机，从库被提升为主库，锁丢失，如何处理该情况？

### Redlock是什么？

redis的作者针对这种情况提出了一种解决方案：Redlock。

Redlock的前提：

1、只部署主库，不需要从库和哨兵。

2、主库需要部署多个，官方推荐至少五个

整体流程：

1、client获取当前时间戳T1；

2、client向五个Redis实例发起加锁请求，每个请求设置超时时间（毫秒级，远小于锁的有效时间），一个实例申请失败则立即申请下一个实例；

3、如果client从大多数获得锁，则再次获取当前时间戳T2， T2 - T1 < 锁的过期时间，则加锁成功，否则失败；

4、加锁成功则操作共享资源，失败则向全部节点发起删除锁的请求

### 关于Redlock的问题

对于Redlock的质疑中有几点：

1、时钟问题

允许误差与运维控制可以解释。

2、网络延迟与进程GC

网络延迟与进程GC可能会导致提交修改时，锁已经过期。Redis作者认为，如果发生这种情况会在1到3中检测出来，通过T2 - T1来判断是否成功，同样的问题对于ZooKeeper也无法解决。

3、fencing token机制

fencing token递增请求ID的思想，raft里面也用过。对于大部分要操作的资源服务器并不具备这种互斥能力。

## 参考文章：

1、[怎样实现redis分布式锁？](https://www.zhihu.com/question/300767410/answer/1931519430)